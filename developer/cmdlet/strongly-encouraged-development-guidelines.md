---
title: 强烈建议在开发指导原则设置 |Microsoft Docs
ms.custom: ''
ms.date: 09/13/2016
ms.reviewer: ''
ms.suite: ''
ms.tgt_pltfrm: ''
ms.topic: article
ms.assetid: 4d68a8f3-fba0-44c5-97b9-9fc191d269a5
caps.latest.revision: 13
ms.openlocfilehash: c11e50913d2654b786e0e8cfeaf41454999bf75e
ms.sourcegitcommit: 5990f04b8042ef2d8e571bec6d5b051e64c9921c
ms.translationtype: MT
ms.contentlocale: zh-CN
ms.lasthandoff: 03/12/2019
ms.locfileid: "57794960"
---
# <a name="strongly-encouraged-development-guidelines"></a><span data-ttu-id="436d3-102">强烈建议的开发指南</span><span class="sxs-lookup"><span data-stu-id="436d3-102">Strongly Encouraged Development Guidelines</span></span>

<span data-ttu-id="436d3-103">本部分介绍当编写 cmdlet 时应遵循的准则。</span><span class="sxs-lookup"><span data-stu-id="436d3-103">This section describes guidelines that you should follow when you write your cmdlets.</span></span> <span data-ttu-id="436d3-104">它们分为设计 cmdlet 和指引，用于编写 cmdlet 代码的准则。</span><span class="sxs-lookup"><span data-stu-id="436d3-104">They are separated into guidelines for designing cmdlets and guidelines for writing your cmdlet code.</span></span> <span data-ttu-id="436d3-105">您可能会发现这些准则不是适用于每个方案。</span><span class="sxs-lookup"><span data-stu-id="436d3-105">You might find that these guidelines are not applicable for every scenario.</span></span> <span data-ttu-id="436d3-106">但是，如果它们适用，并且不遵循这些指导原则，你的用户可能必须在使用 cmdlet 时体验不佳。</span><span class="sxs-lookup"><span data-stu-id="436d3-106">However, if they do apply and you do not follow these guidelines, your users might have a poor experience when they use your cmdlets.</span></span>

## <a name="design-guidelines"></a><span data-ttu-id="436d3-107">设计指南</span><span class="sxs-lookup"><span data-stu-id="436d3-107">Design Guidelines</span></span>

- [<span data-ttu-id="436d3-108">使用特定名词的 Cmdlet 名称 (SD01)</span><span class="sxs-lookup"><span data-stu-id="436d3-108">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>](./strongly-encouraged-development-guidelines.md#use-a-specific-noun-for-a-cmdlet-name-sd01)

- [<span data-ttu-id="436d3-109">使用 pascal 大小写的 Cmdlet 名称 (SD02)</span><span class="sxs-lookup"><span data-stu-id="436d3-109">Use Pascal Case for Cmdlet Names (SD02)</span></span>](./strongly-encouraged-development-guidelines.md#use-pascal-case-for-cmdlet-names-sd02)

- [<span data-ttu-id="436d3-110">参数设计准则 (SD03)</span><span class="sxs-lookup"><span data-stu-id="436d3-110">Parameter Design Guidelines (SD03)</span></span>](./strongly-encouraged-development-guidelines.md#parameter-design-guidelines-sd03)

- [<span data-ttu-id="436d3-111">向用户 (SD04) 提供反馈</span><span class="sxs-lookup"><span data-stu-id="436d3-111">Provide Feedback to the User (SD04)</span></span>](./strongly-encouraged-development-guidelines.md#provide-feedback-to-the-user-sd04)

- [<span data-ttu-id="436d3-112">创建 Cmdlet 帮助文件 (SD05)</span><span class="sxs-lookup"><span data-stu-id="436d3-112">Create a Cmdlet Help File (SD05)</span></span>](./strongly-encouraged-development-guidelines.md#create-a-cmdlet-help-file-sd05)

## <a name="code-guidelines"></a><span data-ttu-id="436d3-113">代码指南</span><span class="sxs-lookup"><span data-stu-id="436d3-113">Code Guidelines</span></span>

- [<span data-ttu-id="436d3-114">编码的参数 (SC01)</span><span class="sxs-lookup"><span data-stu-id="436d3-114">Coding Parameters (SC01)</span></span>](./strongly-encouraged-development-guidelines.md#coding-parameters-sc01)

- [<span data-ttu-id="436d3-115">支持定义完善的管道输入 (SC02)</span><span class="sxs-lookup"><span data-stu-id="436d3-115">Support Well Defined Pipeline Input (SC02)</span></span>](./strongly-encouraged-development-guidelines.md#support-well-defined-pipeline-input-sc02)

- [<span data-ttu-id="436d3-116">单个记录写入管道 (SC03)</span><span class="sxs-lookup"><span data-stu-id="436d3-116">Write Single Records to the Pipeline (SC03)</span></span>](./strongly-encouraged-development-guidelines.md#write-single-records-to-the-pipeline-sc03)

- [<span data-ttu-id="436d3-117">使 Cmdlet 不区分大小写和保留大小写的 (SC04)</span><span class="sxs-lookup"><span data-stu-id="436d3-117">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>](./strongly-encouraged-development-guidelines.md#make-cmdlets-case-insensitive-and-case-preserving-sc04)

## <a name="design-guidelines"></a><span data-ttu-id="436d3-118">设计指南</span><span class="sxs-lookup"><span data-stu-id="436d3-118">Design Guidelines</span></span>

<span data-ttu-id="436d3-119">Cmdlet 以确保使用 cmdlet 和其他 cmdlet 之间一致的用户体验在设计时应遵循以下准则。</span><span class="sxs-lookup"><span data-stu-id="436d3-119">The following guidelines should be followed when designing cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="436d3-120">找到一个设计指导原则适用于你的情况，请务必查看类似的指导原则的代码准则。</span><span class="sxs-lookup"><span data-stu-id="436d3-120">When you find a Design guideline that applies to your situation, be sure to look at the Code guidelines for similar guidelines.</span></span>

### <a name="use-a-specific-noun-for-a-cmdlet-name-sd01"></a><span data-ttu-id="436d3-121">使用特定名词的 Cmdlet 名称 (SD01)</span><span class="sxs-lookup"><span data-stu-id="436d3-121">Use a Specific Noun for a Cmdlet Name (SD01)</span></span>

<span data-ttu-id="436d3-122">Cmdlet 名称中使用的名词必须非常具体，以便用户可以发现 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="436d3-122">Nouns used in cmdlet naming need to be very specific so that the user can discover your cmdlets.</span></span> <span data-ttu-id="436d3-123">前缀"server"产品名称的缩写版本，例如泛型名词。</span><span class="sxs-lookup"><span data-stu-id="436d3-123">Prefix generic nouns such as "server" with a shortened version of the product name.</span></span> <span data-ttu-id="436d3-124">例如，如果某个名词所引用的运行 Microsoft SQL Server 实例的服务器，使用如"SQLServer"名词。</span><span class="sxs-lookup"><span data-stu-id="436d3-124">For example, if a noun refers to a server that is running an instance of Microsoft SQL Server, use a noun such as "SQLServer".</span></span> <span data-ttu-id="436d3-125">特定名词组成和批准的动词的简短列表使用户能够快速发现并避免在 cmdlet 名称之间的重复时预测其功能。</span><span class="sxs-lookup"><span data-stu-id="436d3-125">The combination of specific nouns and the short list of approved verbs enable the user to quickly discover and anticipate functionality while avoiding duplication among cmdlet names.</span></span>

<span data-ttu-id="436d3-126">若要增强用户体验，名词的 cmdlet 名称选择应为单数形式。</span><span class="sxs-lookup"><span data-stu-id="436d3-126">To enhance the user experience, the noun that you choose for a cmdlet name should be singular.</span></span> <span data-ttu-id="436d3-127">例如，使用名称`Get-Process`而不是**Get 进程**。</span><span class="sxs-lookup"><span data-stu-id="436d3-127">For example, use the name `Get-Process` instead of **Get-Processes**.</span></span> <span data-ttu-id="436d3-128">最好是时要遵循此规则的所有 cmdlet 名称，甚至是可能对其多个项执行操作。</span><span class="sxs-lookup"><span data-stu-id="436d3-128">It is best to follow this rule for all cmdlet names, even when a cmdlet is likely to act upon more than one item.</span></span>

### <a name="use-pascal-case-for-cmdlet-names-sd02"></a><span data-ttu-id="436d3-129">使用 pascal 大小写的 Cmdlet 名称 (SD02)</span><span class="sxs-lookup"><span data-stu-id="436d3-129">Use Pascal Case for Cmdlet Names (SD02)</span></span>

<span data-ttu-id="436d3-130">为参数名称使用 Pascal 大小写。</span><span class="sxs-lookup"><span data-stu-id="436d3-130">Use Pascal case for parameter names.</span></span> <span data-ttu-id="436d3-131">换而言之，动词和名词中使用的所有字词的第一个字母大写。</span><span class="sxs-lookup"><span data-stu-id="436d3-131">In other words, capitalize the first letter of verb and all terms used in the noun.</span></span> <span data-ttu-id="436d3-132">例如，"`Clear-ItemProperty`"。</span><span class="sxs-lookup"><span data-stu-id="436d3-132">For example, "`Clear-ItemProperty`".</span></span>

### <a name="parameter-design-guidelines-sd03"></a><span data-ttu-id="436d3-133">参数设计准则 (SD03)</span><span class="sxs-lookup"><span data-stu-id="436d3-133">Parameter Design Guidelines (SD03)</span></span>

<span data-ttu-id="436d3-134">Cmdlet 需要接收的它必须运行的数据的参数和参数，可指示用于确定操作的特征的信息。</span><span class="sxs-lookup"><span data-stu-id="436d3-134">A cmdlet needs parameters that receive the data on which it must operate, and parameters that indicate information that is used to determine the characteristics of the operation.</span></span> <span data-ttu-id="436d3-135">例如，可能有 cmdlet`Name`接收管道，并使用 cmdlet 提供的数据的参数可能具有`Force`参数以指示该 cmdlet，可以被强制执行其操作。</span><span class="sxs-lookup"><span data-stu-id="436d3-135">For example, a cmdlet might have a `Name` parameter that receives data from the pipeline, and the cmdlet might have a `Force` parameter to indicate that the cmdlet can be forced to perform its operation.</span></span> <span data-ttu-id="436d3-136">可以定义一个 cmdlet 的参数的数目没有限制。</span><span class="sxs-lookup"><span data-stu-id="436d3-136">There is no limit to the number of parameters that a cmdlet can define.</span></span>

#### <a name="use-standard-parameter-names"></a><span data-ttu-id="436d3-137">使用标准参数名称</span><span class="sxs-lookup"><span data-stu-id="436d3-137">Use Standard Parameter Names</span></span>

<span data-ttu-id="436d3-138">你的 cmdlet 应使用标准参数名称，以便用户能够快速确定某个特定参数的含义。</span><span class="sxs-lookup"><span data-stu-id="436d3-138">Your cmdlet should use standard parameter names so that the user can quickly determine what a particular parameter means.</span></span> <span data-ttu-id="436d3-139">如果需要更具体的名称，使用标准参数的名称，，然后指定作为别名的更具体的名称。</span><span class="sxs-lookup"><span data-stu-id="436d3-139">If a more specific name is required, use a standard parameter name, and then specify a more specific name as an alias.</span></span> <span data-ttu-id="436d3-140">例如， `Get-Service` cmdlet 具有一个参数具有通用名称 (`Name`) 和更具体的别名 (`ServiceName`)。</span><span class="sxs-lookup"><span data-stu-id="436d3-140">For example, the `Get-Service` cmdlet has a  parameter that has a generic name (`Name`) and a more specific alias (`ServiceName`).</span></span> <span data-ttu-id="436d3-141">这两个术语可以用于指定该参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-141">Both terms can be used to specify the parameter.</span></span>

<span data-ttu-id="436d3-142">有关参数的名称和数据类型的详细信息，请参阅[Cmdlet 参数名称和功能的指导原则](./standard-cmdlet-parameter-names-and-types.md)。</span><span class="sxs-lookup"><span data-stu-id="436d3-142">For more information about parameter names and their data types, see [Cmdlet Parameter Name and Functionality Guidelines](./standard-cmdlet-parameter-names-and-types.md).</span></span>

#### <a name="use-singular-parameter-names"></a><span data-ttu-id="436d3-143">使用单数形式的参数名称</span><span class="sxs-lookup"><span data-stu-id="436d3-143">Use Singular Parameter Names</span></span>

<span data-ttu-id="436d3-144">避免使用其值为单个元素的参数的复数形式的名称。</span><span class="sxs-lookup"><span data-stu-id="436d3-144">Avoid using plural names for parameters whose value is a single element.</span></span> <span data-ttu-id="436d3-145">这包括获取数组的参数或列表，因为用户可能会提供的数组或列表仅包含一个元素。</span><span class="sxs-lookup"><span data-stu-id="436d3-145">This includes parameters that take arrays or lists because the user might supply an array or list with only one element.</span></span>

<span data-ttu-id="436d3-146">应仅在这些情况下，参数的值始终是多个元素值中使用复数形式的参数名称。</span><span class="sxs-lookup"><span data-stu-id="436d3-146">Plural parameter names should be used only in those cases where the value of the parameter is always a multiple-element value.</span></span> <span data-ttu-id="436d3-147">在这些情况下，该 cmdlet 应验证，提供了多个元素，并且该 cmdlet 应显示一条警告向用户如果未提供多个元素。</span><span class="sxs-lookup"><span data-stu-id="436d3-147">In these cases, the cmdlet should verify that multiple elements are supplied, and the cmdlet should display a warning to the user if multiple elements are not supplied.</span></span>

#### <a name="use-pascal-case-for-parameter-names"></a><span data-ttu-id="436d3-148">为参数名称使用 Pascal 大小写</span><span class="sxs-lookup"><span data-stu-id="436d3-148">Use Pascal Case for Parameter Names</span></span>

<span data-ttu-id="436d3-149">为参数名称使用 Pascal 大小写。</span><span class="sxs-lookup"><span data-stu-id="436d3-149">Use Pascal case for parameter names.</span></span> <span data-ttu-id="436d3-150">换而言之，每个单词中的参数名称，包括名称的第一个字母的第一个字母大写。</span><span class="sxs-lookup"><span data-stu-id="436d3-150">In other words, capitalize the first letter of each word in the parameter name, including the first letter of the name.</span></span> <span data-ttu-id="436d3-151">例如，参数名称`ErrorAction`使用正确的大小写。</span><span class="sxs-lookup"><span data-stu-id="436d3-151">For example, the parameter name `ErrorAction` uses the correct capitalization.</span></span> <span data-ttu-id="436d3-152">以下参数名称使用不正确的大写：</span><span class="sxs-lookup"><span data-stu-id="436d3-152">The following parameter names use incorrect capitalization:</span></span>

- `errorAction`

- `erroraction`

#### <a name="parameters-that-take-a-list-of-options"></a><span data-ttu-id="436d3-153">获取选项的列表的参数</span><span class="sxs-lookup"><span data-stu-id="436d3-153">Parameters That Take a List of Options</span></span>

<span data-ttu-id="436d3-154">有两种方法可创建可从一组选项中选择其值的参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-154">There are two ways to create a parameter whose value can be selected from a set of options.</span></span>

- <span data-ttu-id="436d3-155">定义枚举类型 （或使用现有枚举类型），它指定有效的值。</span><span class="sxs-lookup"><span data-stu-id="436d3-155">Define an enumeration type (or use an existing enumeration type) that specifies the valid values.</span></span> <span data-ttu-id="436d3-156">然后，使用枚举类型以创建该类型的参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-156">Then, use the enumeration type to create a parameter of that type.</span></span>

- <span data-ttu-id="436d3-157">添加**ValidateSet**参数声明的属性。</span><span class="sxs-lookup"><span data-stu-id="436d3-157">Add the **ValidateSet** attribute to the parameter declaration.</span></span> <span data-ttu-id="436d3-158">有关此属性的详细信息，请参阅[ValidateSet 特性声明](./validateset-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="436d3-158">For more information about this attribute, see [ValidateSet Attribute Declaration](./validateset-attribute-declaration.md).</span></span>

#### <a name="use-standard-types-for-parameters"></a><span data-ttu-id="436d3-159">使用标准类型作为参数</span><span class="sxs-lookup"><span data-stu-id="436d3-159">Use Standard Types for Parameters</span></span>

<span data-ttu-id="436d3-160">若要确保与其他 cmdlet 保持一致，请对参数使用标准类型，就可能。</span><span class="sxs-lookup"><span data-stu-id="436d3-160">To ensure consistency with other cmdlets, use standard types for parameters where ever possible.</span></span> <span data-ttu-id="436d3-161">应该用于不同的参数的类型的详细信息，请参阅[标准 Cmdlet 参数名称和类型](./standard-cmdlet-parameter-names-and-types.md)。</span><span class="sxs-lookup"><span data-stu-id="436d3-161">For more information about the types that should be used for different parameter, see [Standard Cmdlet Parameter Names and Types](./standard-cmdlet-parameter-names-and-types.md).</span></span> <span data-ttu-id="436d3-162">本主题提供指向介绍的名称和组的标准参数，例如"活动参数"的.NET Framework 类型的几个主题。</span><span class="sxs-lookup"><span data-stu-id="436d3-162">This topic provides links to several topics that describe the names and .NET Framework types for groups of standard parameters, such as the "activity parameters".</span></span>

#### <a name="use-strongly-typed-net-framework-types"></a><span data-ttu-id="436d3-163">使用强类型化的.NET Framework 类型</span><span class="sxs-lookup"><span data-stu-id="436d3-163">Use Strongly-Typed .NET Framework Types</span></span>

<span data-ttu-id="436d3-164">参数应定义为.NET Framework 类型，以提供更好的参数验证。</span><span class="sxs-lookup"><span data-stu-id="436d3-164">Parameters should be defined as .NET Framework types to provide better parameter validation.</span></span> <span data-ttu-id="436d3-165">例如，被限制为一个值从一组值的参数应定义为枚举类型。</span><span class="sxs-lookup"><span data-stu-id="436d3-165">For example, parameters that are restricted to one value from a set of values should be defined as an enumeration type.</span></span> <span data-ttu-id="436d3-166">若要支持的统一资源标识符 (URI) 值，定义为参数[System.Uri](/dotnet/api/System.Uri)类型。</span><span class="sxs-lookup"><span data-stu-id="436d3-166">To support a Uniform Resource Identifier (URI) value, define the parameter as a [System.Uri](/dotnet/api/System.Uri) type.</span></span> <span data-ttu-id="436d3-167">避免以外的所有的自由格式文本属性的基本字符串参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-167">Avoid basic string parameters for all but free-form text properties.</span></span>

#### <a name="use-consistent-parameter-types"></a><span data-ttu-id="436d3-168">使用一致的参数类型</span><span class="sxs-lookup"><span data-stu-id="436d3-168">Use Consistent Parameter Types</span></span>

<span data-ttu-id="436d3-169">由多个 cmdlet 中使用相同的参数时，始终使用相同的参数类型。</span><span class="sxs-lookup"><span data-stu-id="436d3-169">When the same parameter is used by multiple cmdlets, always use the same parameter type.</span></span>  <span data-ttu-id="436d3-170">例如，如果`Process`参数是[System.Int16](/dotnet/api/System.Int16)类型的一个 cmdlet，禁止`Process`另一个 cmdlet 的参数[System.Uint16](/dotnet/api/System.UInt16)类型。</span><span class="sxs-lookup"><span data-stu-id="436d3-170">For example, if the `Process` parameter is an [System.Int16](/dotnet/api/System.Int16) type for one cmdlet, do not make the `Process` parameter for another cmdlet a [System.Uint16](/dotnet/api/System.UInt16) type.</span></span>

#### <a name="parameters-that-take-true-and-false"></a><span data-ttu-id="436d3-171">参数采用 True 和 False</span><span class="sxs-lookup"><span data-stu-id="436d3-171">Parameters That Take True and False</span></span>

<span data-ttu-id="436d3-172">如果你参数仅采用`true`并`false`，此参数定义为类型[System.Management.Automation.Switchparameter](/dotnet/api/System.Management.Automation.SwitchParameter)。</span><span class="sxs-lookup"><span data-stu-id="436d3-172">If your parameter takes only `true` and `false`, define the parameter as type [System.Management.Automation.Switchparameter](/dotnet/api/System.Management.Automation.SwitchParameter).</span></span> <span data-ttu-id="436d3-173">开关参数被视为`true`当命令中指定。</span><span class="sxs-lookup"><span data-stu-id="436d3-173">A switch parameter is treated as `true` when it is specified in a command.</span></span> <span data-ttu-id="436d3-174">如果在命令中不包括参数，则 Windows PowerShell 会考虑参数的值`false`。</span><span class="sxs-lookup"><span data-stu-id="436d3-174">If the parameter is not included in a command, Windows PowerShell considers the value of the parameter to be `false`.</span></span> <span data-ttu-id="436d3-175">未定义布尔参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-175">Do not define Boolean parameters.</span></span>

<span data-ttu-id="436d3-176">如果参数需要 3 个值之间进行区分： $true、 $false 和"未指定"，然后定义类型可以为 Null 的参数\<bool >。</span><span class="sxs-lookup"><span data-stu-id="436d3-176">If your parameter needs to differentiate between 3 values: $true, $false and "unspecified", then define a parameter of type Nullable\<bool>.</span></span>  <span data-ttu-id="436d3-177">需要第三，"未指定"的值通常发生在该 cmdlet 可以修改对象的布尔属性。</span><span class="sxs-lookup"><span data-stu-id="436d3-177">The need for a 3rd, "unspecified" value typically occurs when the cmdlet can modify a Boolean property of an object.</span></span> <span data-ttu-id="436d3-178">在这种情况下"未指定"意味着若要更改属性的当前值。</span><span class="sxs-lookup"><span data-stu-id="436d3-178">In this case "unspecified" means to not change the current value of the property.</span></span>

#### <a name="support-arrays-for-parameters"></a><span data-ttu-id="436d3-179">支持的参数数组</span><span class="sxs-lookup"><span data-stu-id="436d3-179">Support Arrays for Parameters</span></span>

<span data-ttu-id="436d3-180">通常情况下，用户必须执行针对多个自变量相同的操作。</span><span class="sxs-lookup"><span data-stu-id="436d3-180">Frequently, users must perform the same operation against multiple arguments.</span></span> <span data-ttu-id="436d3-181">对于这些用户，cmdlet 应作为参数输入，以便用户可以将参数传递给 Windows PowerShell 变量作为参数接受一个数组。</span><span class="sxs-lookup"><span data-stu-id="436d3-181">For these users, a cmdlet should accept an array as parameter input so that a user can pass the arguments into the parameter as a Windows PowerShell variable.</span></span> <span data-ttu-id="436d3-182">例如， [Get-process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet 用于标识要检索的进程的名称的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="436d3-182">For example, the [Get-Process](/powershell/module/Microsoft.PowerShell.Management/Get-Process) cmdlet uses an array for the strings that identify the names of the processes to retrieve.</span></span>

#### <a name="support-the-passthru-parameter"></a><span data-ttu-id="436d3-183">支持 PassThru 参数</span><span class="sxs-lookup"><span data-stu-id="436d3-183">Support the PassThru Parameter</span></span>

<span data-ttu-id="436d3-184">默认情况下，许多 cmdlet 修改的系统，如[Stop-process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet，充当"接收器"的对象并不返回结果。</span><span class="sxs-lookup"><span data-stu-id="436d3-184">By default, many cmdlets that modify the system, such as the [Stop-Process](/powershell/module/Microsoft.PowerShell.Management/Stop-Process) cmdlet, act as "sinks" for objects and do not return a result.</span></span> <span data-ttu-id="436d3-185">这些 cmdlet 应实现`PassThru`参数强制 cmdlet 返回的对象。</span><span class="sxs-lookup"><span data-stu-id="436d3-185">These cmdlet should implement the `PassThru` parameter to force the cmdlet to return an object.</span></span> <span data-ttu-id="436d3-186">当`PassThru`指定参数，该 cmdlet 返回一个对象使用调用[System.Management.Automation.Cmdlet.Writeobject\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject)方法。</span><span class="sxs-lookup"><span data-stu-id="436d3-186">When the `PassThru` parameter is specified, the cmdlet returns an object by using a call to the [System.Management.Automation.Cmdlet.Writeobject\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="436d3-187">例如，以下命令停止 Calc 进程，并将生成进程传递到管道。</span><span class="sxs-lookup"><span data-stu-id="436d3-187">For example, the following command stops the Calc process and passes the resultant process to the pipeline.</span></span>

```powershell
Stop-Process calc -passthru
```

<span data-ttu-id="436d3-188">在大多数情况下，添加、 集和新建 cmdlet 应支持`PassThru`参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-188">In most cases, Add, Set, and New cmdlets should support a `PassThru` parameter.</span></span>

#### <a name="support-parameter-sets"></a><span data-ttu-id="436d3-189">支持的参数集</span><span class="sxs-lookup"><span data-stu-id="436d3-189">Support Parameter Sets</span></span>

<span data-ttu-id="436d3-190">Cmdlet 用于完成单一用途。</span><span class="sxs-lookup"><span data-stu-id="436d3-190">A cmdlet is intended to accomplish a single purpose.</span></span> <span data-ttu-id="436d3-191">但是，经常没有多个方法来描述该操作或操作目标。</span><span class="sxs-lookup"><span data-stu-id="436d3-191">However, there is frequently more than one way to describe the operation or the operation target.</span></span> <span data-ttu-id="436d3-192">例如，进程可能将其标识，通过其名称、 其标识符，或将进程对象。</span><span class="sxs-lookup"><span data-stu-id="436d3-192">For example, a process might be identified by its name, by its identifier, or by a process object.</span></span> <span data-ttu-id="436d3-193">该 cmdlet 应支持其目标的所有合理的表示形式。</span><span class="sxs-lookup"><span data-stu-id="436d3-193">The cmdlet should support all the reasonable representations of its targets.</span></span> <span data-ttu-id="436d3-194">通常情况下，该 cmdlet 通过指定的参数 （也称为参数集） 一起运行，集来满足此要求。</span><span class="sxs-lookup"><span data-stu-id="436d3-194">Normally, the cmdlet satisfies this requirement by specifying sets of parameters (referred to as parameter sets) that operate together.</span></span> <span data-ttu-id="436d3-195">单个参数可以属于任意数量的参数集。</span><span class="sxs-lookup"><span data-stu-id="436d3-195">A single parameter can belong to any number of parameter sets.</span></span> <span data-ttu-id="436d3-196">有关参数集的详细信息，请参阅[Cmdlet 参数可设置](./cmdlet-parameter-sets.md)。</span><span class="sxs-lookup"><span data-stu-id="436d3-196">For more information about parameter sets, see [Cmdlet Parameter Sets](./cmdlet-parameter-sets.md).</span></span>

<span data-ttu-id="436d3-197">当指定的参数集时，设置到 ValueFromPipeline 集中只有一个参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-197">When you specify parameter sets, set only one parameter in the set to ValueFromPipeline.</span></span> <span data-ttu-id="436d3-198">有关如何声明的详细信息**参数**属性，请参阅[ParameterAttribute 声明](./parameter-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="436d3-198">For more information about how to declare the **Parameter** attribute, see [ParameterAttribute Declaration](./parameter-attribute-declaration.md).</span></span>

<span data-ttu-id="436d3-199">当使用不同参数集时，根据定义的默认参数集**Cmdlet**属性。</span><span class="sxs-lookup"><span data-stu-id="436d3-199">When parameter sets are used, the default parameter set is defined by the **Cmdlet** attribute.</span></span> <span data-ttu-id="436d3-200">默认参数集应包括最有可能在交互式 Windows PowerShell 会话中使用的参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-200">The default parameter set should include the parameters most likely to be used in an interactive Windows PowerShell session.</span></span> <span data-ttu-id="436d3-201">有关如何声明的详细信息**Cmdlet**属性，请参阅[CmdletAttribute 声明](./cmdlet-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="436d3-201">For more information about how to declare the **Cmdlet** attribute, see [CmdletAttribute Declaration](./cmdlet-attribute-declaration.md).</span></span>

### <a name="provide-feedback-to-the-user-sd04"></a><span data-ttu-id="436d3-202">向用户 (SD04) 提供反馈</span><span class="sxs-lookup"><span data-stu-id="436d3-202">Provide Feedback to the User (SD04)</span></span>

<span data-ttu-id="436d3-203">使用本节中的准则向用户提供反馈。</span><span class="sxs-lookup"><span data-stu-id="436d3-203">Use the guidelines in this section to provide feedback to the user.</span></span> <span data-ttu-id="436d3-204">此反馈可让用户需要注意的系统中所发生并做出更好地管理决策。</span><span class="sxs-lookup"><span data-stu-id="436d3-204">This feedback allows the user to be aware of what is occurring in the system and to make better administrative decisions.</span></span>

<span data-ttu-id="436d3-205">Windows PowerShell 运行时，用户可以指定如何处理到每个调用的输出`Write`通过设置首选项变量的方法。</span><span class="sxs-lookup"><span data-stu-id="436d3-205">The Windows PowerShell runtime allows a user to specify how to handle output from each call to the `Write` method by setting a preference variable.</span></span> <span data-ttu-id="436d3-206">用户可以设置多个首选项变量，其中包括用于确定系统是否应显示信息和确定系统是否应采取进一步操作之前查询用户的变量的变量。</span><span class="sxs-lookup"><span data-stu-id="436d3-206">The user can set several preference variables, including a variable that determines whether the system should display information and a variable that determines whether the system should query the user before taking further action.</span></span>

#### <a name="support-the-writewarning-writeverbose-and-writedebug-methods"></a><span data-ttu-id="436d3-207">支持 WriteWarning、 WriteVerbose 和 WriteDebug 方法</span><span class="sxs-lookup"><span data-stu-id="436d3-207">Support the WriteWarning, WriteVerbose, and WriteDebug Methods</span></span>

<span data-ttu-id="436d3-208">Cmdlet 应调用[System.Management.Automation.Cmdlet.Writewarning\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning)方法，该 cmdlet 时要执行的操作可能产生意外的结果。</span><span class="sxs-lookup"><span data-stu-id="436d3-208">A cmdlet should call the [System.Management.Automation.Cmdlet.Writewarning\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteWarning) method when the cmdlet is about to perform an operation that might have an unintended result.</span></span> <span data-ttu-id="436d3-209">例如，一个 cmdlet 应调用此方法，如果该 cmdlet 将覆盖只读文件。</span><span class="sxs-lookup"><span data-stu-id="436d3-209">For example, a cmdlet should call this method if the cmdlet is about to overwrite a read-only file.</span></span>

<span data-ttu-id="436d3-210">Cmdlet 应调用[System.Management.Automation.Cmdlet.Writeverbose\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose)方法时用户需要深入了解有关该 cmdlet 的用途。</span><span class="sxs-lookup"><span data-stu-id="436d3-210">A cmdlet should call the [System.Management.Automation.Cmdlet.Writeverbose\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method when the user requires some detail about what the cmdlet is doing.</span></span> <span data-ttu-id="436d3-211">例如，如果 cmdlet 作者大家都有可能需要有关该 cmdlet 正在执行什么操作的详细信息的情况下 cmdlet 应调用此信息。</span><span class="sxs-lookup"><span data-stu-id="436d3-211">For example, a cmdlet should call this information if the cmdlet author feels that there are scenarios that might require more information about what the cmdlet is doing.</span></span>

<span data-ttu-id="436d3-212">该 cmdlet 应调用[System.Management.Automation.Cmdlet.Writedebug\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug)时开发人员或产品的支持工程师必须了解什么损坏了 cmdlet 操作的方法。</span><span class="sxs-lookup"><span data-stu-id="436d3-212">The cmdlet should call the [System.Management.Automation.Cmdlet.Writedebug\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method when a developer or product support engineer must understand what has corrupted the cmdlet operation.</span></span> <span data-ttu-id="436d3-213">没有必要 cmdlet 来调用[System.Management.Automation.Cmdlet.Writedebug\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug)方法中调用的相同代码[System.Management.Automation.Cmdlet.Writeverbose\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose)方法因为`Debug`参数提供了这两组信息。</span><span class="sxs-lookup"><span data-stu-id="436d3-213">It is not necessary for the cmdlet to call the [System.Management.Automation.Cmdlet.Writedebug\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteDebug) method in the same code that calls the [System.Management.Automation.Cmdlet.Writeverbose\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteVerbose) method because the `Debug` parameter presents both sets of information.</span></span>

#### <a name="support-writeprogress-for-operations-that-take-a-long-time"></a><span data-ttu-id="436d3-214">支持 WriteProgress 需要很长时间的操作</span><span class="sxs-lookup"><span data-stu-id="436d3-214">Support WriteProgress for Operations that take a Long Time</span></span>

<span data-ttu-id="436d3-215">Cmdlet 操作的需要很长时间才能完成，不能在后台运行应支持进度报告通过定期调用[System.Management.Automation.Cmdlet.Writeprogress\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress)方法。</span><span class="sxs-lookup"><span data-stu-id="436d3-215">Cmdlet operations that take a long time to complete and that cannot run in the background should support progress reporting through periodic calls to the [System.Management.Automation.Cmdlet.Writeprogress\*](/dotnet/api/System.Management.Automation.Cmdlet.WriteProgress) method.</span></span>

#### <a name="use-the-host-interfaces"></a><span data-ttu-id="436d3-216">使用主机接口</span><span class="sxs-lookup"><span data-stu-id="436d3-216">Use the Host Interfaces</span></span>

<span data-ttu-id="436d3-217">有时，cmdlet 必须直接与用户通信而不是通过使用各种编写或应支持的方法[System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet)类。</span><span class="sxs-lookup"><span data-stu-id="436d3-217">Occasionally, a cmdlet must communicate directly with the user instead of by using the various Write or Should methods supported by the [System.Management.Automation.Cmdlet](/dotnet/api/System.Management.Automation.Cmdlet) class.</span></span> <span data-ttu-id="436d3-218">在这种情况下，该 cmdlet 应派生自[System.Management.Automation.Pscmdlet](/dotnet/api/System.Management.Automation.PSCmdlet)类并使用[System.Management.Automation.Pscmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host)属性。</span><span class="sxs-lookup"><span data-stu-id="436d3-218">In this case, the cmdlet should derive from the [System.Management.Automation.Pscmdlet](/dotnet/api/System.Management.Automation.PSCmdlet) class and use the [System.Management.Automation.Pscmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="436d3-219">此属性支持不同级别的通信类型，包括 PromptForChoice、 提示和 WriteLine/ReadLine 类型。</span><span class="sxs-lookup"><span data-stu-id="436d3-219">This property supports different levels of communication type, including the PromptForChoice, Prompt, and WriteLine/ReadLine types.</span></span> <span data-ttu-id="436d3-220">最特定的级别，它还提供可读取和写入单个键以及处理缓冲区的方式。</span><span class="sxs-lookup"><span data-stu-id="436d3-220">At the most specific level, it also provides ways to read and write individual keys and to deal with buffers.</span></span>

<span data-ttu-id="436d3-221">除非 cmdlet 专门用于生成图形用户界面 (GUI)，它应不绕过主机通过使用[System.Management.Automation.Pscmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host)属性。</span><span class="sxs-lookup"><span data-stu-id="436d3-221">Unless a cmdlet is specifically designed to generate a graphical user interface (GUI), it should not bypass the host by using the [System.Management.Automation.Pscmdlet.Host\*](/dotnet/api/System.Management.Automation.PSCmdlet.Host) property.</span></span> <span data-ttu-id="436d3-222">为生成 GUI 而设计的 cmdlet 的一个示例是[Out-gridview](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet。</span><span class="sxs-lookup"><span data-stu-id="436d3-222">An example of a cmdlet that is designed to generate a GUI is the [Out-GridView](/powershell/module/Microsoft.PowerShell.Utility/Out-GridView) cmdlet.</span></span>

> [!NOTE]
> <span data-ttu-id="436d3-223">不应使用 Cmdlet [System.Console](/dotnet/api/System.Console) API。</span><span class="sxs-lookup"><span data-stu-id="436d3-223">Cmdlets should not use the [System.Console](/dotnet/api/System.Console) API.</span></span>

### <a name="create-a-cmdlet-help-file-sd05"></a><span data-ttu-id="436d3-224">创建 Cmdlet 帮助文件 (SD05)</span><span class="sxs-lookup"><span data-stu-id="436d3-224">Create a Cmdlet Help File (SD05)</span></span>

<span data-ttu-id="436d3-225">为每个 cmdlet 的程序集创建 Help.xml 文件，其中包含有关该 cmdlet 的信息。</span><span class="sxs-lookup"><span data-stu-id="436d3-225">For each cmdlet assembly, create a Help.xml file that contains information about the cmdlet.</span></span> <span data-ttu-id="436d3-226">此信息包括 cmdlet，该 cmdlet 的参数的说明，该 cmdlet 的使用和的详细信息的示例的说明。</span><span class="sxs-lookup"><span data-stu-id="436d3-226">This information includes a description of the cmdlet, descriptions of the cmdlet's parameters, examples of the cmdlet's use, and more.</span></span>

## <a name="code-guidelines"></a><span data-ttu-id="436d3-227">代码指南</span><span class="sxs-lookup"><span data-stu-id="436d3-227">Code Guidelines</span></span>

<span data-ttu-id="436d3-228">在编写代码以确保使用 cmdlet 和其他 cmdlet 之间一致的用户体验的 cmdlet 时，应遵循以下准则。</span><span class="sxs-lookup"><span data-stu-id="436d3-228">The following guidelines should be followed when coding cmdlets to ensure a consistent user experience between using your cmdlets and other cmdlets.</span></span> <span data-ttu-id="436d3-229">找到适用于您的具体情况的代码准则，请务必查看类似的指导原则的设计指南。</span><span class="sxs-lookup"><span data-stu-id="436d3-229">When you find a Code guideline that applies to your situation, be sure to look at the Design guidelines for similar guidelines.</span></span>

### <a name="coding-parameters-sc01"></a><span data-ttu-id="436d3-230">编码的参数 (SC01)</span><span class="sxs-lookup"><span data-stu-id="436d3-230">Coding Parameters (SC01)</span></span>

<span data-ttu-id="436d3-231">定义通过声明使用修饰在 cmdlet 类的公共属性的参数**参数**属性。</span><span class="sxs-lookup"><span data-stu-id="436d3-231">Define a parameter by declaring a public property of the cmdlet class that is decorated with the **Parameter** attribute.</span></span> <span data-ttu-id="436d3-232">参数不需要是 cmdlet 派生的.NET Framework 类的静态成员。</span><span class="sxs-lookup"><span data-stu-id="436d3-232">Parameters do not have to be static members of the derived .NET Framework class for the cmdlet.</span></span> <span data-ttu-id="436d3-233">有关如何声明的详细信息**参数**属性，请参阅[参数特性声明](./parameter-attribute-declaration.md)。</span><span class="sxs-lookup"><span data-stu-id="436d3-233">For more information about how to declare the **Parameter** attribute, see [Parameter Attribute Declaration](./parameter-attribute-declaration.md).</span></span>

#### <a name="support-windows-powershell-paths"></a><span data-ttu-id="436d3-234">支持 Windows PowerShell 路径</span><span class="sxs-lookup"><span data-stu-id="436d3-234">Support Windows PowerShell Paths</span></span>

<span data-ttu-id="436d3-235">Windows PowerShell 路径是用于规范化的命名空间的访问权限的机制。</span><span class="sxs-lookup"><span data-stu-id="436d3-235">The Windows PowerShell path is the mechanism for normalizing access to namespaces.</span></span> <span data-ttu-id="436d3-236">当将 Windows PowerShell 路径分配到该 cmdlet 中的参数时，用户可以定义自定义"驱动器"充当特定路径的快捷方式。</span><span class="sxs-lookup"><span data-stu-id="436d3-236">When you assign a Windows PowerShell path to a parameter in the cmdlet, the user can define a custom "drive" that acts as a shortcut to a specific path.</span></span> <span data-ttu-id="436d3-237">当用户将指定此类驱动器时，存储的数据，例如数据在注册表中，可以使用一致的方式。</span><span class="sxs-lookup"><span data-stu-id="436d3-237">When a user designates such a drive, stored data, such as data in the Registry, can be used in a consistent way.</span></span>

<span data-ttu-id="436d3-238">如果你的 cmdlet 允许用户指定一个文件或数据源，它应定义的类型参数[System.String](/dotnet/api/System.String)。</span><span class="sxs-lookup"><span data-stu-id="436d3-238">If your cmdlet allows the user to specify a file or a data source, it should define a parameter of type [System.String](/dotnet/api/System.String).</span></span> <span data-ttu-id="436d3-239">如果支持多个驱动器，则类型应为数组。</span><span class="sxs-lookup"><span data-stu-id="436d3-239">If more than one drive is supported, the type should be an array.</span></span> <span data-ttu-id="436d3-240">参数的名称应`Path`，使用的别名`PSPath`。</span><span class="sxs-lookup"><span data-stu-id="436d3-240">The name of the parameter should be `Path`, with an alias of `PSPath`.</span></span> <span data-ttu-id="436d3-241">此外，`Path`参数应支持通配符字符。</span><span class="sxs-lookup"><span data-stu-id="436d3-241">Additionally, the `Path` parameter should support wildcard characters.</span></span> <span data-ttu-id="436d3-242">如果对通配符字符不是必需的支持，定义`LiteralPath`参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-242">If support for wildcard characters is not required, define a `LiteralPath` parameter.</span></span>

<span data-ttu-id="436d3-243">如果该 cmdlet 读取或写入的数据必须是一个文件，该 cmdlet 应接受 Windows PowerShell 路径输入，而应该使用 cmdlet [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path)属性来转换 Windows为文件系统识别的路径的 PowerShell 路径。</span><span class="sxs-lookup"><span data-stu-id="436d3-243">If the data that the cmdlet reads or writes has to be a file, the cmdlet should accept Windows PowerShell path input, and the cmdlet should use the [System.Management.Automation.Sessionstate.Path](/dotnet/api/System.Management.Automation.SessionState.Path) property to translate the Windows PowerShell paths into paths that the file system recognizes.</span></span> <span data-ttu-id="436d3-244">特定机制包括以下方法：</span><span class="sxs-lookup"><span data-stu-id="436d3-244">The specific mechanisms include the following methods:</span></span>

- [<span data-ttu-id="436d3-245">System.Management.Automation.Pscmdlet.Getresolvedproviderpathfrompspath</span><span class="sxs-lookup"><span data-stu-id="436d3-245">System.Management.Automation.Pscmdlet.Getresolvedproviderpathfrompspath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="436d3-246">System.Management.Automation.Pscmdlet.Getunresolvedproviderpathfrompspath</span><span class="sxs-lookup"><span data-stu-id="436d3-246">System.Management.Automation.Pscmdlet.Getunresolvedproviderpathfrompspath</span></span>](/dotnet/api/System.Management.Automation.PSCmdlet.GetUnresolvedProviderPathFromPSPath)

- [<span data-ttu-id="436d3-247">System.Management.Automation.Pathintrinsics.Getresolvedproviderpathfrompspath</span><span class="sxs-lookup"><span data-stu-id="436d3-247">System.Management.Automation.Pathintrinsics.Getresolvedproviderpathfrompspath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetResolvedProviderPathFromPSPath)

- [<span data-ttu-id="436d3-248">System.Management.Automation.Pathintrinsics.Getunresolvedproviderpathfrompspath</span><span class="sxs-lookup"><span data-stu-id="436d3-248">System.Management.Automation.Pathintrinsics.Getunresolvedproviderpathfrompspath</span></span>](/dotnet/api/System.Management.Automation.PathIntrinsics.GetUnresolvedProviderPathFromPSPath)

<span data-ttu-id="436d3-249">如果该 cmdlet 读取或写入的数据仅是一组字符串而不是文件，该 cmdlet 应使用的提供程序的内容信息 (`Content`成员) 来读取和写入。</span><span class="sxs-lookup"><span data-stu-id="436d3-249">If the data that the cmdlet reads or writes is only a set of strings instead of a file, the cmdlet should use the provider content information (`Content` member) to read and write.</span></span> <span data-ttu-id="436d3-250">从获取此信息[System.Management.Automation.Provider.Cmdletprovider.Invokeprovider\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider)属性。</span><span class="sxs-lookup"><span data-stu-id="436d3-250">This information is obtained from the [System.Management.Automation.Provider.Cmdletprovider.Invokeprovider\*](/dotnet/api/System.Management.Automation.Provider.CmdletProvider.InvokeProvider) property.</span></span> <span data-ttu-id="436d3-251">这些机制允许参与的读取和写入数据的其他数据存储。</span><span class="sxs-lookup"><span data-stu-id="436d3-251">These mechanisms allow other data stores to participate in the reading and writing of data.</span></span>

#### <a name="support-wildcard-characters"></a><span data-ttu-id="436d3-252">支持通配符字符</span><span class="sxs-lookup"><span data-stu-id="436d3-252">Support Wildcard Characters</span></span>

<span data-ttu-id="436d3-253">如果可能，cmdlet 应支持通配符字符。</span><span class="sxs-lookup"><span data-stu-id="436d3-253">A cmdlet should support wildcard characters if possible.</span></span> <span data-ttu-id="436d3-254">（尤其是在参数采用一个字符串来标识一组对象中的一个对象），对通配符字符的支持会发生在置于某个 cmdlet 中的多个位置。</span><span class="sxs-lookup"><span data-stu-id="436d3-254">Support for wildcard characters occurs in many places in a cmdlet (especially when a parameter takes a string to identify one object from a set of objects).</span></span> <span data-ttu-id="436d3-255">例如，示例**停止 Proc** cmdlet 从[StopProc 教程](./stopproc-tutorial.md)定义`Name`参数，以处理表示进程名称的字符串。</span><span class="sxs-lookup"><span data-stu-id="436d3-255">For example, the sample **Stop-Proc** cmdlet from the [StopProc Tutorial](./stopproc-tutorial.md) defines a `Name` parameter to handle strings that represent process names.</span></span> <span data-ttu-id="436d3-256">此参数支持通配符字符，使用户可以轻松地指定要停止的进程。</span><span class="sxs-lookup"><span data-stu-id="436d3-256">This parameter supports wildcard characters so that the user can easily specify the processes to stop.</span></span>

<span data-ttu-id="436d3-257">如果支持的通配符字符可用，cmdlet 操作通常会生成一个数组。</span><span class="sxs-lookup"><span data-stu-id="436d3-257">When support for wildcard characters is available, a cmdlet operation usually produces an array.</span></span> <span data-ttu-id="436d3-258">有时，不值得以支持一个数组，因为用户可能会一次使用单个项。</span><span class="sxs-lookup"><span data-stu-id="436d3-258">Occasionally, it does not make sense to support an array because the user might use only a single item at a time.</span></span> <span data-ttu-id="436d3-259">例如， [Set-location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet 不需要支持一个数组，因为用户设置一个位置。</span><span class="sxs-lookup"><span data-stu-id="436d3-259">For example, the [Set-Location](/powershell/module/Microsoft.PowerShell.Management/Set-Location) cmdlet does not need to support an array because the user is setting only a single location.</span></span> <span data-ttu-id="436d3-260">在此情况下，该 cmdlet 仍然支持通配符，但它会强制解析为单个位置。</span><span class="sxs-lookup"><span data-stu-id="436d3-260">In this instance, the cmdlet still supports wildcard characters, but it forces resolution to a single location.</span></span>

<span data-ttu-id="436d3-261">有关通配符字符模式的详细信息，请参阅[中的 Cmdlet 参数支持通配符](./supporting-wildcard-characters-in-cmdlet-parameters.md)。</span><span class="sxs-lookup"><span data-stu-id="436d3-261">For more information about wildcard-character patterns, see [Supporting Wildcard Characters in Cmdlet Parameters](./supporting-wildcard-characters-in-cmdlet-parameters.md).</span></span>

#### <a name="defining-objects"></a><span data-ttu-id="436d3-262">定义对象</span><span class="sxs-lookup"><span data-stu-id="436d3-262">Defining Objects</span></span>

<span data-ttu-id="436d3-263">本部分包含用于定义对象的 cmdlet 和扩展现有对象的原则。</span><span class="sxs-lookup"><span data-stu-id="436d3-263">This section contains guidelines for defining objects for cmdlets and for extending existing objects.</span></span>

##### <a name="define-standard-members"></a><span data-ttu-id="436d3-264">定义标准的成员</span><span class="sxs-lookup"><span data-stu-id="436d3-264">Define Standard Members</span></span>

<span data-ttu-id="436d3-265">定义要扩展的自定义的 Types.ps1xml 文件 （使用 Windows PowerShell Types.ps1xml 文件作为模板） 中的对象类型的标准成员。</span><span class="sxs-lookup"><span data-stu-id="436d3-265">Define standard members to extend an object type in a custom Types.ps1xml file (use the Windows PowerShell Types.ps1xml file as a template).</span></span> <span data-ttu-id="436d3-266">由具有名称 PSStandardMembers 的节点定义标准的成员。</span><span class="sxs-lookup"><span data-stu-id="436d3-266">Standard members are defined by a node with the name PSStandardMembers.</span></span> <span data-ttu-id="436d3-267">这些定义允许其他 cmdlet 和 Windows PowerShell 运行时以一致的方式使用您的对象。</span><span class="sxs-lookup"><span data-stu-id="436d3-267">These definitions allow other cmdlets and the Windows PowerShell runtime to work with your object in a consistent way.</span></span>

##### <a name="define-objectmembers-to-be-used-as-parameters"></a><span data-ttu-id="436d3-268">定义要用作参数的 ObjectMembers</span><span class="sxs-lookup"><span data-stu-id="436d3-268">Define ObjectMembers to Be Used as Parameters</span></span>

<span data-ttu-id="436d3-269">如果您正在设计的 cmdlet 的对象，请确保其成员映射到将使用该 cmdlet 的参数直接。</span><span class="sxs-lookup"><span data-stu-id="436d3-269">If you are designing an object for a cmdlet, ensure that its members map directly to the parameters of the cmdlets that will use it.</span></span> <span data-ttu-id="436d3-270">此映射使对象轻松地发送到管道，并从一个 cmdlet 传递到另一个。</span><span class="sxs-lookup"><span data-stu-id="436d3-270">This mapping allows the object to be easily sent to the pipeline and to be passed from one cmdlet to another.</span></span>

<span data-ttu-id="436d3-271">由 cmdlet 返回的预先存在.NET Framework 对象经常缺少某些重要或不方便使用的成员所需的脚本开发人员或用户。</span><span class="sxs-lookup"><span data-stu-id="436d3-271">Preexisting .NET Framework objects that are returned by cmdlets are frequently missing some important or convenient members that are needed by the script developer or user.</span></span> <span data-ttu-id="436d3-272">这些缺少的成员可以是用于显示和创建正确的成员名称，以便该对象可以正确地传递给管道尤为重要。</span><span class="sxs-lookup"><span data-stu-id="436d3-272">These missing members can be particularly important for display and for creating the correct member names so that the object can be correctly passed to the pipeline.</span></span> <span data-ttu-id="436d3-273">创建自定义的 Types.ps1xml 文件，以记录这些必需的成员。</span><span class="sxs-lookup"><span data-stu-id="436d3-273">Create a custom Types.ps1xml file to document these required members.</span></span> <span data-ttu-id="436d3-274">在创建此文件时，我们建议以下命名约定： *< Your_Product_Name >*。Types.ps1xml。</span><span class="sxs-lookup"><span data-stu-id="436d3-274">When you create this file, we recommend the following naming convention: *<Your_Product_Name>*.Types.ps1xml.</span></span>

<span data-ttu-id="436d3-275">例如，可以添加`Mode`编写脚本属性设置为[System.IO.Fileinfo](/dotnet/api/System.IO.FileInfo)要更清楚地显示文件的属性类型。</span><span class="sxs-lookup"><span data-stu-id="436d3-275">For example, you could add a `Mode` script property to the [System.IO.Fileinfo](/dotnet/api/System.IO.FileInfo) type to display the attributes of a file more clearly.</span></span> <span data-ttu-id="436d3-276">此外，还可以添加`Count`别名属性设置为[System.Array](/dotnet/api/System.Array)类型才允许使用一致的该属性名称 (而不是`Length`)。</span><span class="sxs-lookup"><span data-stu-id="436d3-276">Additionally, you could add a `Count` alias property to the [System.Array](/dotnet/api/System.Array) type to allow the consistent use of that property name (instead of `Length`).</span></span>

##### <a name="implement-the-icomparable-interface"></a><span data-ttu-id="436d3-277">实现 IComparable 接口</span><span class="sxs-lookup"><span data-stu-id="436d3-277">Implement the IComparable Interface</span></span>

<span data-ttu-id="436d3-278">实现[System.Icomparable](/dotnet/api/System.IComparable)输出的所有对象的接口。</span><span class="sxs-lookup"><span data-stu-id="436d3-278">Implement a [System.Icomparable](/dotnet/api/System.IComparable) interface on all output objects.</span></span> <span data-ttu-id="436d3-279">这允许要轻松地输送到不同的排序和分析 cmdlet 的输出对象。</span><span class="sxs-lookup"><span data-stu-id="436d3-279">This allows the output objects to be easily piped to various sorting and analysis cmdlets.</span></span>

##### <a name="update-display-information"></a><span data-ttu-id="436d3-280">更新显示信息</span><span class="sxs-lookup"><span data-stu-id="436d3-280">Update Display Information</span></span>

<span data-ttu-id="436d3-281">如果对象的显示不提供预期的结果，创建自定义 *\<YourProductName >*。该对象的 Format.ps1xml 文件。</span><span class="sxs-lookup"><span data-stu-id="436d3-281">If the display for an object does not provide the expected results, create a custom *\<YourProductName>*.Format.ps1xml file for that object.</span></span>

### <a name="support-well-defined-pipeline-input-sc02"></a><span data-ttu-id="436d3-282">支持定义完善的管道输入 (SC02)</span><span class="sxs-lookup"><span data-stu-id="436d3-282">Support Well Defined Pipeline Input (SC02)</span></span>

#### <a name="implement-for-the-middle-of-a-pipeline"></a><span data-ttu-id="436d3-283">管道中间的实现</span><span class="sxs-lookup"><span data-stu-id="436d3-283">Implement for the Middle of a Pipeline</span></span>

<span data-ttu-id="436d3-284">实现假定将从管道的中间调用它的 cmdlet （即，其他 cmdlet 将生成其输入或使用其输出）。</span><span class="sxs-lookup"><span data-stu-id="436d3-284">Implement a cmdlet assuming that it will be called from the middle of a pipeline (that is, other cmdlets will produce its input or consume its output).</span></span> <span data-ttu-id="436d3-285">例如，您可能认为`Get-Process`cmdlet，因为它会生成数据，仅用作管道中的第一个 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="436d3-285">For example, you might assume that the `Get-Process` cmdlet, because it generates data, is used only as the first cmdlet in a pipeline.</span></span> <span data-ttu-id="436d3-286">但是，因为此 cmdlet 专为管道的中间，此 cmdlet 允许上述 cmdlet 或数据管道来指定要检索的进程中。</span><span class="sxs-lookup"><span data-stu-id="436d3-286">However, because this cmdlet is designed for the middle of a pipeline, this cmdlet allows previous cmdlets or data in the pipeline to specify the processes to retrieve.</span></span>

#### <a name="support-input-from-the-pipeline"></a><span data-ttu-id="436d3-287">支持来自管道的输入</span><span class="sxs-lookup"><span data-stu-id="436d3-287">Support Input from the Pipeline</span></span>

<span data-ttu-id="436d3-288">每个参数中为 cmdlet 设置，包括支持来自管道的输入的至少一个参数。</span><span class="sxs-lookup"><span data-stu-id="436d3-288">In each parameter set for a cmdlet, include at least one parameter that supports input from the pipeline.</span></span> <span data-ttu-id="436d3-289">对管道输入支持允许用户检索数据或对象，将其发送到正确的参数集，并将结果传递给某个 cmdlet 直接。</span><span class="sxs-lookup"><span data-stu-id="436d3-289">Support for pipeline input allows the user to retrieve data or objects, to send them to the correct parameter set, and to pass the results directly to a cmdlet.</span></span>

<span data-ttu-id="436d3-290">一个参数接受来自管道的输入，如果**参数**属性包括`ValueFromPipeline`关键字，`ValueFromPipelineByPropertyName`关键字属性或在其声明中的这两个关键字。</span><span class="sxs-lookup"><span data-stu-id="436d3-290">A parameter accepts input from the pipeline if the **Parameter** attribute includes the `ValueFromPipeline` keyword, the `ValueFromPipelineByPropertyName` keyword attribute, or both keywords in its  declaration.</span></span> <span data-ttu-id="436d3-291">如果任何参数的参数中设置的支持`ValueFromPipeline`或`ValueFromPipelineByPropertyName`有意义的方式的关键字，该 cmdlet 不能放置后另一个 cmdlet 中，因为它将忽略任何管道输入。</span><span class="sxs-lookup"><span data-stu-id="436d3-291">If none of the parameters in a parameter set support the `ValueFromPipeline` or `ValueFromPipelineByPropertyName` keywords, the cmdlet cannot meaningfully be placed after another cmdlet because it will ignore any pipeline input.</span></span>

#### <a name="support-the-processrecord-method"></a><span data-ttu-id="436d3-292">支持 ProcessRecord 方法</span><span class="sxs-lookup"><span data-stu-id="436d3-292">Support the ProcessRecord Method</span></span>

<span data-ttu-id="436d3-293">若要接受管道中前一个 cmdlet 中的所有记录，你的 cmdlet 必须实现[System.Management.Automation.Cmdlet.Processrecord\*](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord)方法。</span><span class="sxs-lookup"><span data-stu-id="436d3-293">To accept all the records from the preceding cmdlet in the pipeline, your cmdlet must implement the [System.Management.Automation.Cmdlet.Processrecord\*](/dotnet/api/System.Management.Automation.Cmdlet.ProcessRecord) method.</span></span> <span data-ttu-id="436d3-294">Windows PowerShell 调用此方法多次，一次发送到你的 cmdlet 的每个记录。</span><span class="sxs-lookup"><span data-stu-id="436d3-294">Windows PowerShell calls this method multiple times, once for every record that is sent to your cmdlet.</span></span>

### <a name="write-single-records-to-the-pipeline-sc03"></a><span data-ttu-id="436d3-295">单个记录写入管道 (SC03)</span><span class="sxs-lookup"><span data-stu-id="436d3-295">Write Single Records to the Pipeline (SC03)</span></span>

<span data-ttu-id="436d3-296">当一个 cmdlet 返回对象时，该 cmdlet 应写入对象立即生成它们。</span><span class="sxs-lookup"><span data-stu-id="436d3-296">When a cmdlet returns objects, the cmdlet should write the objects immediately as they are generated.</span></span> <span data-ttu-id="436d3-297">该 cmdlet 不应阻止它们以便它们缓冲到组合数组。</span><span class="sxs-lookup"><span data-stu-id="436d3-297">The cmdlet should not hold them in order to buffer them into a combined array.</span></span> <span data-ttu-id="436d3-298">然后，作为输入接收对象的 cmdlet 将能够处理、 显示或处理和显示的输出对象而不会延迟。</span><span class="sxs-lookup"><span data-stu-id="436d3-298">The cmdlets that receive the objects as input will then be able to process, display, or process and display the output objects without delay.</span></span> <span data-ttu-id="436d3-299">Cmdlet 将生成输出对象应调用一次一个地[System.Management.Automation.Cmdlet.Writeobject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject)方法。</span><span class="sxs-lookup"><span data-stu-id="436d3-299">A cmdlet that generates output objects one at a time should call the [System.Management.Automation.Cmdlet.Writeobject](/dotnet/api/System.Management.Automation.Cmdlet.WriteObject) method.</span></span> <span data-ttu-id="436d3-300">在批处理中生成输出对象 （例如，因为基础 API 返回的输出对象数组） 的 cmdlet 应调用[System.Managemet.Automation.Cmdlet.Writeobject](/dotnet/api/System.Managemet.Automation.Cmdlet.WriteObject)方法与第二个参数设置到`true`。</span><span class="sxs-lookup"><span data-stu-id="436d3-300">A cmdlet that generates output objects in batches (for example, because an underlying API returns an array of output objects) should call the [System.Managemet.Automation.Cmdlet.Writeobject](/dotnet/api/System.Managemet.Automation.Cmdlet.WriteObject) Method with its second parameter set to `true`.</span></span>

### <a name="make-cmdlets-case-insensitive-and-case-preserving-sc04"></a><span data-ttu-id="436d3-301">使 Cmdlet 不区分大小写和保留大小写的 (SC04)</span><span class="sxs-lookup"><span data-stu-id="436d3-301">Make Cmdlets Case-Insensitive and Case-Preserving (SC04)</span></span>

<span data-ttu-id="436d3-302">默认情况下，Windows PowerShell 本身就是不区分大小写。</span><span class="sxs-lookup"><span data-stu-id="436d3-302">By default, Windows PowerShell itself is case-insensitive.</span></span> <span data-ttu-id="436d3-303">但是，因为它可以处理许多预先存在的系统，Windows PowerShell 会保留案例，以便简化操作和兼容性。</span><span class="sxs-lookup"><span data-stu-id="436d3-303">However, because it deals with many preexisting systems, Windows PowerShell does preserve case for ease of operation and compatibility.</span></span> <span data-ttu-id="436d3-304">换而言之，如果以大写形式提供一个字符，则 Windows PowerShell 将使其以大写字母。</span><span class="sxs-lookup"><span data-stu-id="436d3-304">In other words, if a character is supplied in uppercase letters, Windows PowerShell keeps it in uppercase letters.</span></span> <span data-ttu-id="436d3-305">对于正常的系统，cmdlet 需要遵循此约定。</span><span class="sxs-lookup"><span data-stu-id="436d3-305">For systems to work well, a cmdlet needs to follow this convention.</span></span> <span data-ttu-id="436d3-306">如果可能，它应运行的不区分大小写的方式。</span><span class="sxs-lookup"><span data-stu-id="436d3-306">If possible, it should operate in a case-insensitive way.</span></span> <span data-ttu-id="436d3-307">它应，但是，保留原始的用例出现在命令中更高版本或管道中的 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="436d3-307">It should, however, preserve the original case for cmdlets that occur later in a command or in the pipeline.</span></span>

## <a name="see-also"></a><span data-ttu-id="436d3-308">另请参阅</span><span class="sxs-lookup"><span data-stu-id="436d3-308">See Also</span></span>

[<span data-ttu-id="436d3-309">所需的开发指导原则</span><span class="sxs-lookup"><span data-stu-id="436d3-309">Required Development Guidelines</span></span>](./required-development-guidelines.md)

[<span data-ttu-id="436d3-310">咨询开发指导原则</span><span class="sxs-lookup"><span data-stu-id="436d3-310">Advisory Development Guidelines</span></span>](./advisory-development-guidelines.md)

[<span data-ttu-id="436d3-311">编写 Windows PowerShell Cmdlet</span><span class="sxs-lookup"><span data-stu-id="436d3-311">Writing a Windows PowerShell Cmdlet</span></span>](./writing-a-windows-powershell-cmdlet.md)
